module mojo_top (
    
    input clk,              // 50MHz clock.
    input rst_n,            // reset button (active low).
    input cclk,             // configuration clock, AVR ready when high.
    output spi_miso,        // AVR SPI MISO.
    input spi_ss,           // AVR SPI Slave Select.
    input spi_mosi,         // AVR SPI MOSI.
    input spi_sck,          // AVR SPI Clock.
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel).
    input avr_tx,           // AVR TX (FPGA RX).
    output avr_rx,          // AVR RX (FPGA TX).
    input avr_rx_busy,      // AVR RX buffer full.
    output io_led [24],   // LEDs on IO Shield.
    input io_dip [24], // DIP switches on IO Shield.
    
    // input buttons -- change when connected to IO
    input up,
    input down,
    input left,
    input right,
    input reset,
    input select,
    
    output r_red[8],
    output r_green[8],
    output col[8]
    
  ) {
  
  sig rst;
  
  // modules
  board_generator board_gen_call;
  control ctrl_call;
  data_mem data_mem_call(.clk(clk));
  check check_call(.clk(clk));
  alu_main alu_call;
  matrix_decoder decoder;
  
  .clk(clk) {
    reset_conditioner reset_cond;
    
    // states
    fsm state = {SELECT, WAIT, CHECKA, CHECKB, CHECKWIN, WIN};
    
    // registers
    dff level[2];
    dff reg_d;
    dff reg_r;
  }
  
  always {
    
    io_led = io_dip; //led on the io shield are all connected to the io dip
    reset_cond.in = ~rst_n; // Input raw inverted reset signal.
    rst = reset_cond.out;   // Conditioned reset.
    spi_miso = bz;          // Not using SPI.
    spi_channel = bzzzz;    // Not using flags.
    avr_rx = bz;            // Not using serial port.
    
    // connect buttons
    /*
    down = io_dip[];
    up = io_dip[];
    left = io_dip[];
    right = io_dip[];
    select = io_dip[];
    reset = io_dip[];
    */
    
    // do we need to initalise registers?
    
    // d handler
    if (down) { reg_d.d = 0; }
    if (up) { reg_d.d = 1; }
    if (left) { reg_d.d = 2; }
    if (right) { reg_d.d = 3; }
    
    // if no direction buttons were pressed
    else{reg_d.d = bz;}
    
    if (reset) { reg_r.d = 1; } // if pressed
    else{reg_r.d = reg_r.q;} // if not pressed
    
    case(state.q) {
      state.SELECT:
        // inputs for control module
        ctrl_call.state = 0;
        ctrl_call.r = reg_r.q;
        ctrl_call.d = reg_d.q;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        // next state
        if (select){
          state.d = state.WAIT;
        }
      
      state.WAIT:
        ctrl_call.state = 1;
        ctrl_call.d = reg_d.q;
        ctrl_call.r = reg_r.q;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        if (up | down | left | right){
          state.d = state.CHECKA;
        }
      
      state.CHECKA:
        ctrl_call.state = 2;
        ctrl_call.d = reg_d.q;
        ctrl_call.r = reg_r.q;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        // go straight to CHECKB
        state.d = state.CHECKB;
      
      state.CHECKB:
        ctrl_call.state = 3;
        ctrl_call.d = reg_d.q;
        ctrl_call.r = reg_r.q;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        // go straight to state CHECKWIN
        state.d = state.CHECKWIN;
      
      state.CHECKWIN:
        ctrl_call.state = 4;
        ctrl_call.d = bz;
        ctrl_call.r = bz;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        if (data_mem_call.r0 == 2) {
          state.d = state.WIN;
        } else if (data_mem_call.r0 == 1) {
          reg_r.d = 1; // force reset
          state.d = state.WAIT;
        } else {
          reg_r.d = 0;
          state.d = state.WAIT;
        }
      
      state.WIN:
        ctrl_call.state = 5;
        ctrl_call.d = reg_d.q;
        ctrl_call.r = reg_r.q;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        // some win stuff
        
        if (up | down | left | right | reset | select){
          state.d = state.SELECT;
        }
      
      default:
        ctrl_call.state = 0;
        ctrl_call.r = reg_r.q;
        ctrl_call.d = reg_d.q;
        
        // processing to board
        board_gen_call.sel_level = ctrl_call.sel_level;
        board_gen_call.sel_display = ctrl_call.sel_display;
        board_gen_call.level_i = level.q;
        level.d = board_gen_call.level_o;
        
        // board to data
        data_mem_call.level_adr_i = level.q;
        
        // ctrl to data
        data_mem_call.sel_start = ctrl_call.sel_start;
        data_mem_call.sel_map = ctrl_call.sel_map;
        
        // ctrl to decoder
        decoder.sel_new_pos = ctrl_call.sel_new_pos;
        
        // data memory to decoder
        decoder.curr_tp = data_mem_call.curr_tp;
        decoder.mapdata = data_mem_call.curr_map;
        
        // decoder to data memory
        data_mem_call.new_tp_i = decoder.new_tp;
        
        // data to alu
        alu_call.alufn = ctrl_call.alufn;
      alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
      alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.curr_tp;
        
        // check module
        check_call.value = alu_call.alu;
        check_call.check_win = ctrl_call.check_win;
        
        // check to data_mem
        data_mem_call.r0_i = check_call.r0;
        
        // led_decoder to get map data from data_mem_call
        //led_matrix = data_mem_call.out;
        
        if (select){
          state.d = state.WAIT;
        }
      
      
      
    }
  }
}