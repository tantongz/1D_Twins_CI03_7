module mojo_top (
    
    input clk,              // 50MHz clock.
    input rst_n,            // reset button (active low).
    input cclk,             // configuration clock, AVR ready when high.
    output spi_miso,        // AVR SPI MISO.
    input spi_ss,           // AVR SPI Slave Select.
    input spi_mosi,         // AVR SPI MOSI.
    input spi_sck,          // AVR SPI Clock.
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel).
    input avr_tx,           // AVR TX (FPGA RX).
    output avr_rx,          // AVR RX (FPGA TX).
    input avr_rx_busy,      // AVR RX buffer full.
    output io_led [24],   // LEDs on IO Shield.
    input io_dip [24], // DIP switches on IO Shield.
    output r_red[8],
    output r_green[8],
    output col[8]

) {


  // processing module to board generator
  sig lx;

  // data memory to decoder
  sig tpmux;
  
  // registers
  dff level[2],
  dff r,
  dff reg_d,
  dff state,

  // modules
  board_generator board_gen_call,
  control ctrl_call,
  data_mem data_mem_call,
  check check_call, // TO DO:  MAKE CHECK
  alu alu_call,

  .clk(clk) {
    
    reset_conditioner reset_cond;

      .rst(rst) {
          
          fsm state = {SELECT, WAIT, CHECKA, CHECKB, CHECKWIN, WIN};
        
       }
  }
  
   always {
    
    io_led = io_dip; //led on the io shield are all connected to the io dip
    reset_cond.in = ~rst_n; // Input raw inverted reset signal.
    rst = reset_cond.out;   // Conditioned reset.
    spi_miso = bz;          // Not using SPI.
    spi_channel = bzzzz;    // Not using flags.
    avr_rx = bz;            // Not using serial port.


    // d handler
    if (up) { reg_d = 1 };
    if (down) { reg_d = 0 };
    if (left) { reg_d = 2 };
    if (right) { reg_d = 3 };

    if (reset) { ctrl_call.r = 1 }

    case(state.q) {
        state.SELECT:   ctrl_call.s = 0
                        ctrl_call.r = z
                        if (reg_d == 1 | reg_d == 3 ) {
                            ctrl_call.d = 1;
                        } else if (reg_d == 2 | reg_d == 0) {
                            ctrl_call.d = 0;
                        }

                        // processing to board
                        lx = ctrl_call.sel_level ? level + b01 : level - b01;
                        board_gen_call.in = ctrl_call.sel_display ? level : lx;

                        // board to data
                        data_mem_call.level_adr_i = board_gen_call.out;

                        // ctrl to data
                        data_mem_call.sel_start = ctrl_call.sel_start;

                        // led_decoder to get map data from data_mem_call

                        if (select){
                            state.d = state.WAIT
                        }

        state.WAIT:     ctrl_call.s = 1

                        // processing to board
                        board_gen_call.in = level;

                        // board to data
                        data_mem_call.level_adr_i = board_gen_call.out;

                        // ctrl to data
                        data_mem_call.sel_start = ctrl_call.sel_start;
                        data_mem_call.sel_map = ctrl_call.sel_map;

                        

                        // led_decoder to get map data from data_mem_call

                        if (up | down | left | right){
                            state.d = state.CHECKA
                        }

        state.CHECKA:   ctrl_call.s = 2
                        ctrl_call.d = reg_d;

                        // processing to board
                        board_gen_call.in = level;

                        // board to data
                        data_mem_call.level_adr_i = board_gen_call.out;

                        // ctrl to data
                        data_mem_call.sel_start = ctrl_call.sel_start;
                        data_mem_call.sel_map = ctrl_call.sel_map;

                        // data memory to decoder
                        if(ctrl_call.sel_new_pos == 0){
                            tpmux = data_mem_call.curr_tp - b000001;
                        } else if(ctrl_call.sel_new_pos == 1){
                            tpmux = data_mem_call.curr_tp + b000001;
                        } else if(ctrl_call.sel_new_pos == 2){
                            tpmux = data_mem_call.curr_tp - b001000;
                        } else if(ctrl_call.sel_new_pos == 3){
                            tpmux = data_mem_call.curr_tp + b001000;
                        }

                        decoder.tp = tpmux;

                        decoder.mapdata = data_mem_call.curr_map;

                        data_mem_call.new_tp = decoder.out ? data_mem_call.curr_tp : tpmux;

                        // data memory to alu
                        alu_call.alufn = ctrl_call.alufn
                        alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
                        alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.new_tp;
                        
                        if (ctrl_call.check_win == 0) {
                            check_call.r1_i = alu_call.out;
                        }

                        // led_decoder to get map data from data_mem_call

                        if (up | down | left | right){
                            state.d = state.CHECKA
                        }

                        state.d = state.CHECKB

        state.CHECKB:   ctrl_call.s = 3
                        ctrl_call.d = reg_d;

                        // processing to board
                        board_gen_call.in = level;

                        // board to data
                        data_mem_call.level_adr_i = board_gen_call.out;

                        // ctrl to data
                        data_mem_call.sel_start = ctrl_call.sel_start;
                        data_mem_call.sel_map = ctrl_call.sel_map;

                        // data memory to decoder
                        if(ctrl_call.sel_new_pos == 0){
                            tpmux = data_mem_call.curr_tp - b000001;
                        } else if(ctrl_call.sel_new_pos == 1){
                            tpmux = data_mem_call.curr_tp + b000001;
                        } else if(ctrl_call.sel_new_pos == 2){
                            tpmux = data_mem_call.curr_tp - b001000;
                        } else if(ctrl_call.sel_new_pos == 3){
                            tpmux = data_mem_call.curr_tp + b001000;
                        }

                        decoder.tp = tpmux;

                        decoder.mapdata = data_mem_call.curr_map;

                        data_mem_call.new_tp = decoder.out ? data_mem_call.curr_tp : tpmux;

                        // data memory to alu
                        alu_call.alufn = ctrl_call.alufn
                        alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
                        alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.new_tp;
                        
                        if (ctrl_call.check_win == 1) {
                            check_call.r2_i = alu_call.out;
                        }

                        // led_decoder to get map data from data_mem_call

                        if (up | down | left | right){
                            state.d = state.CHECKA
                        }

                        state.d = state.CHECKWIN

        state.CHECKWIN: ctrl_call.s = 4

                        // data memory to alu
                        alu_call.alufn = ctrl_call.alufn
                        alu_call.a = ctrl_call.sel_check ? check_call.r1 : data_mem_call.curr_ep;
                        alu_call.b = ctrl_call.sel_check ? check_call.r2 : data_mem_call.new_tp;
                        
                        if (ctrl_call.check_win == 2) {
                            check_call.r0_i = alu_call.out;
                        }

                        if (check_call.r0 == 2) {
                            state.d = state.WIN;
                        } else if (check_call.r0 == 1) {
                            ctrl_call.r = 1 // force reset
                            state.d = state.MOVE;
                        } else {
                            state.d = state.MOVE;
                        }

        state.WIN:      ctrl_call.s = 3

                        // some win stuff

                        if (up | down | left | right | reset | select){
                            state.d = state.SELECT
                        }
    }
  }
}