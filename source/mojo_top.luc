module mojo_top (
    
    input clk,              // 50MHz clock.
    input rst_n,            // reset button (active low).
    input cclk,             // configuration clock, AVR ready when high.
    output spi_miso,        // AVR SPI MISO.
    input spi_ss,           // AVR SPI Slave Select.
    input spi_mosi,         // AVR SPI MOSI.
    input spi_sck,          // AVR SPI Clock.
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel).
    input avr_tx,           // AVR TX (FPGA RX).
    output avr_rx,          // AVR RX (FPGA TX).
    input avr_rx_busy,      // AVR RX buffer full.
    
    input right_btn,
    input left_btn,
    input up_btn,
    input down_btn,
    
    input reset_btn,
    input start_btn,
    
    output r_red[8],
    output r_green[8],
    output col[8],
    output led[8] //built-in leds
    
  ) {
  
  // pipeline button_cond[1] (#DEPTH(5), .clk(clk)).
  sig rst;                  // Reset signal.
  matrix_display mat_dis(.clk(clk), .rst(rst));
  map_rom map;
  map_to_display map_to_dis;
  
  control_n ctrl;
  // board_generator board_gen;
  
  
  
  .clk(clk) {
    
    reset_conditioner reset_cond;
    
    // Setup of edge detectors for buttons.
    edge_detector right_edge_detector(#RISE(1), #FALL(0));
    edge_detector left_edge_detector(#RISE(1), #FALL(0));
    edge_detector up_edge_detector(#RISE(1), #FALL(0));
    edge_detector down_edge_detector(#RISE(1), #FALL(0));
    
    button_conditioner right_conditioner;
    button_conditioner left_conditioner;
    button_conditioner up_conditioner;
    button_conditioner down_conditioner;
    
    edge_detector reset_edge_detector(#RISE(1), #FALL(0));
    edge_detector start_edge_detector(#RISE(1), #FALL(0));
    
    button_conditioner reset_conditioner;
    button_conditioner start_conditioner;
    
    fsm state(#INIT(MENU_WAIT)) = {MENU_WAIT, MENU_UPDATE};
    
    dff level[2](#INIT(3));
    dff reg_d[3](#INIT(4));
    
    dff see[3];
    
    .rst(rst) {
    
    }
  }
  
  sig lx[2];
  
  always {
    
    map.level_adr = level.q;
    
    reset_cond.in = ~rst_n; // Input raw inverted reset signal.
    rst = reset_cond.out;   // Conditioned reset.
    spi_miso = bz;          // Not using SPI.
    spi_channel = bzzzz;    // Not using flags.
    avr_rx = bz;            // Not using serial port.
    
    r_red = mat_dis.r_red;
    r_green = mat_dis.r_green;
    col = mat_dis.col;
    
    mat_dis.red = map_to_dis.red;
    mat_dis.green = map_to_dis.green;
    
    map_to_dis.map_a = map.map_a;
    map_to_dis.map_b = map.map_b;
    
    map_to_dis.tp_a = map.sp_a;
    map_to_dis.tp_b = map.sp_b;
    
    map_to_dis.ep_a = map.ep_a;
    map_to_dis.ep_b = map.ep_b;
    
    
    led = b00000000;
    led = see.q;
    ctrl.state = 0;
    ctrl.direction = 0;
    
    case(state.q) {
      state.MENU_WAIT:
        
        if (right_edge_detector.out) {
          reg_d.d = 3;
        } else if (left_edge_detector.out) {
          reg_d.d = 2;
        } else if (up_edge_detector.out) {
          reg_d.d = 1;
        } else if (down_edge_detector.out) {
          reg_d.d = 0;
        } else {        
          reg_d.d = 4;
        }
        
        if (reg_d.q != 4) {
          state.d = state.MENU_UPDATE; 
          
          // Prepare control signals for next state.    
          ctrl.state = 1;         
          ctrl.direction = reg_d.q;
          see.d = reg_d.q;
          // reg_d.q will be cleared in the next iteration, so save it in see
          // to use it in MENU_UPDATE.
        }
      
      state.MENU_UPDATE:
        ctrl.state = 1;
        ctrl.direction = see.q;
        
        if (ctrl.sel_level) {
          level.d = level.q + 1;
        } else {
          level.d = level.q - 1; 
        }
        
        reg_d.d = 4;
        see.d = 4;
        state.d = state.MENU_WAIT;
    }
    
    // Button logic.
    right_conditioner.in = right_btn;
    left_conditioner.in = left_btn;
    up_conditioner.in = up_btn;
    down_conditioner.in = down_btn;
    
    right_edge_detector.in = right_conditioner.out;
    left_edge_detector.in = left_conditioner.out;
    up_edge_detector.in = up_conditioner.out;
    down_edge_detector.in = down_conditioner.out;
    
    reset_conditioner.in = reset_btn;
    start_conditioner.in = start_btn;
    
    reset_edge_detector.in = reset_conditioner.out;
    start_edge_detector.in = start_conditioner.out;
    
  }
}